---
title: js线程
date: 2017-03-15 21:52:53
tags:js 线程

---
#feature：
>理论上说，js是单线程。但是实际操作中，我们能明显感觉到js能够一边执行ajax请求一边渲染页面，或者查看devtool的时候也能明显发现时间线不止一条。那这是怎么回事呢。
在参考了很多文章之后，我有了答案。
js代码始终在一个线程上执行，即js引擎线程。但是浏览器并不只有一个线程，它还有其他线程，概括来说，一共有以下线程
1. js引擎线程
2. 界面渲染线程
3. 事件触发线程
4. http请求线程
5. EventLoop轮询的处理线程


任务队列

>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。多线程可以将任务放到不同的线程中去处理。CPU的调度单位是线程，它会在不同的线程之间切换，任务是隶属于线程的。

>如果一个线程中，任务排队是因为计算量大，CPU忙不过来，倒也算了。但是很多时候CPU处理一个线程时是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等结果出来，任务才能往下执行。

>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回头，把挂起的任务继续执行下去。

js的运行机制
>于是，所有任务可以分成两种，一种是同步任务，另一种是异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
也就是:
>（1）所有同步任务都在主线程上执行，形成一个执行栈。  
>（2）主线程之外，还存在一个”任务队列”。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。  
>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。  
>（4）主线程不断重复上面的第三步。
##事件和回调函数

>“任务队列”是事件队列（也可以理解成消息队列），表示相关的异步任务可以进入“执行栈”了。主线程读取“任务队列”，这个过程是循环不断的。  
>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入“任务队列”，等待主线程读取。  
>异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。
##Event Loop

主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件轮询）。上图中，主线程运行的时候，产生堆（heap）和栈（stack）。只要栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。

任务队列中的任务，是“回调函数”指定的，然后通过事件触发添加进去的，是一种异步任务。而在页面初始化时，主线程执行的任务是同步任务。

需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行
#扩展
##实现多线程-worker线程
[javascript-js实现多线程-worker线程](http://www.cnblogs.com/haodawang/articles/5850822.html)
参考
[为什么JavaScript是单线程](http://www.cnblogs.com/zhongxinWang/p/4334510.html)  

[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)
